Microarry pre-processing for Illumina BeadArray data
=====================================================

## Project Directory and Files
```{r Files, eval=FALSE}

# Data Directory
"/media/D/expression/GAP_Expression"

# Data Files Exported from GenomeStudio
control_probe_profile_Final_Report.txt
Group_Probe_Profile_Final_Report.txt
probe_annotation_Final_Report.txt
sample_table_Final_Report.txt

# Input for lumiR
Sample_and_Control_Probe_Profile_FinalReport.txt 

# User Provided Data Files
# Use NA to record missing values in batch_info.txt
# Use Unknown to record missing values in pheno_info.txt 
pheno_info.txt # REQUIRED COLUMNS (MATCH FORMAT SHOWN HERE ie SEX not Sex or Gender etc!):- "Sample.ID","SEX","GROUPS","TISSUE","PHENOTYPE","Study_ID"
batch_info.txt # REQUIRED COLUMNS:- "Sample.ID","RIN","RNA_YIELD" and any other related batch info eg dates or processing. 
```
***********************************************************************************************************************************************************

# Begin R
Start R and call the following

```{r begin_R, eval=TRUE}
rm(list=ls())
options(stringsAsFactors = FALSE)
```

## setwd
This is the full path to the directory where all the raw genomestudio output is stored

```{r setwd, eval=TRUE}
setwd("/media/D/sjnewhouse/GENE_EXPRESSION")
```

## load libs
```{r loadLibs, eval=TRUE}
# Load libraries 
library(lumi)
library(annotate)
library(lumiHumanAll.db)
library(affy)
library(cluster)
library(impute)
library(WGCNA)
library(gplots)
library(limma)
library(vsn)
library(MBCB)
library(lumiHumanIDMapping)
library(scatterplot3d)
library(relaimpo)
library(plyr)
library(ggplot2)

```

## load source file with some processing functions
```{r loadSource, eval=TRUE}
# path to gene expression processing scripts
path_to_scripts <- "/media/D/sjnewhouse/GENE_EXPRESSION" 
# load 'em
source(paste(path_to_scripts,"/sjnewhouse_misc_R.R",sep=""))
ls()
```

## set project settings and I/O
User is asked to manually provide these options. This sets the working directoty, prjoect name, input and output files, along with qc options for transformation and normalisation methods. 

```{r setProjectOptions, eval=TRUE}
# project directory
project_dir <- "/media/D/expression/GAP_Expression"

# set working dir again
setwd(project_dir)

# project name
project_name <- "GAPtest01"

# output directory for lumi process and plots
out_dir <- paste(project_dir,"/",project_name,"_lumi_processing" ,sep="")

# make project pre-processing directory
make_dir_command <- paste(" if [ ! -e ",out_dir," ]; then mkdir ",out_dir,"; fi",sep="")

system( make_dir_command )

# genomestudio reports
gs_report  <- "/media/D/expression/GAP_Expression/final_reports_genomestudio/Sample_and_Control_Probe_Profile_FinalReport.txt"
gs_probe   <- "/media/D/expression/GAP_Expression/final_reports_genomestudio/Group_Probe_Profile_Final_Report.txt" # genomestudio report
gs_sample  <- "/media/D/expression/GAP_Expression/final_reports_genomestudio/sample_table_Final_Report.txt" # genomestudio report
gs_control <- "/media/D/expression/GAP_Expression/final_reports_genomestudio/control_probe_profile_Final_Report.txt" # genomestudio report
anno_table <- "/media/D/expression/GAP_Expression/final_reports_genomestudio/probe_annotation_Final_Report.txt"

# sample information
# FILE NAME must contain : Sample.ID,SEX,GROUPS,TISSUE,PHENOTYPE,Study_ID
pheno_file <- "/media/D/expression/GAP_Expression/final_reports_genomestudio/pheno_info.txt" 

# batch information
tech_pheno_file <-"/media/D/expression/GAP_Expression/final_reports_genomestudio/batch_info.txt"

# detection call rate threshold
probe_det <- 80
sample_det <- 80

# flag for gender and sampleNetwork 
sex_check <- 1   # DO THIS!! I'm not providing an option to skip this
iac_check <- 1   # DO THIS!! I'm not providing an option to skip this
iac_sd_thrs <- 2 # 2 or 3

# Model based background correction method (MLE as default)
# All data should be background correceted. The recomended methods is MBCB (Model-based Background Correction for Beadarray)
# URL http://www.bioconductor.org/packages/release/bioc/html/MBCB.html
mbcb_method <- "MLE"

# Transformation method
transform_method <- "log2" ## "vst" # log2, vst or both

# Normalisation method
norm_method <- "rsn" ## "rsn" # quantile, rsn, or both

# write settings to file
project_settings <- data.frame(
  project_dir=project_dir,
  project_name=project_name,
  out_dir=out_dir,
  gs_report=gs_report,
  gs_probe=gs_probe,
  gs_sample=gs_sample,
  gs_control=gs_control,
  anno_table=anno_table,
  pheno_file=pheno_file,
  tech_pheno_file=tech_pheno_file,
  probe_det=probe_det,
  sample_det=sample_det,
  sex_check=sex_check,
  iac_check=iac_check,
  iac_sd_thrs=iac_sd_thrs,
  mbcb_method=mbcb_method,
  transform_method=transform_method,
  norm_method=norm_method
  )

# some data wrangling
project_settings <- as.data.frame(t(project_settings))
colnames(project_settings) <- "Project_Setting"
project_settings$Project_Variable <- rownames(project_settings)
project_settings <- project_settings[,c("Project_Variable","Project_Setting")]

# write table to out_dir
write.table(project_settings, file=paste(out_dir,"/",project_name,".project_settings.csv",sep=""),row.names=FALSE,quote=FALSE,sep=",")

# check settings
project_settings

```
***********************************************************************************************************************************************************

BEGIN PRE-PROCESSING
=====================

Raw Expression Set
-------------------

## 1. read raw gene expression data 
```{r lumiR, eval=TRUE}

# raw input 
# This is the 1) Probe Profile, 2) Control Probe Profile and 3) Sample Table, Final Reports exported from GenomeStudio, all concatenated 
gs_report

# read raw gene expression data from genomestudio reports and create ExpressionSet

eset_raw <- lumiR( paste(gs_report), 
                  lib.mapping="lumiHumanIDMapping",
                  checkDupId=TRUE,
                  detectionTh = 0.01,
                  convertNuID=TRUE,
                  inputAnnotation=TRUE,
                  annotationColumn=c('PROBE_ID','CHROMOSOME','SYMBOL','DEFINITION','ACCESSION','ENTREZ_GENE_ID',
                                       'PROBE_TYPE','PROBE_START','PROBE_SEQUENCE','PROBE_CHR_ORIENTATION',
                                       'PROBE_COORDINATES','CHROMOSOME','TRANSCRIPT','ILMN_GENE','REFSEQ_ID','UNIGENE_ID','SYMBOL','PROTEIN_PRODUCT'),
                   QC=TRUE)

# check it
eset_raw

```

## 2. read in sample and batch information
```{r readSamplePhenoAndBatchInfo, eval=TRUE}

# gs_sample
if(is.na(gs_sample))  stop(" WARNING!: YOU HAVENT PROVIDED ANY SAMPLE INFORMATION!!!" )
gs_sample

gs_sample_data <- read.table(paste(gs_sample) ,skip=8,as.is=T,fill=T,head=T,sep="\t")
rownames(gs_sample_data) <- gs_sample_data.ID
gs_sample_data <- gs_sample_data[,names(gs_sample_data)!="X"] # added this as genomestudio likes to add mystery columns to the end of this report 
n_samples <- dim(gs_sample_data)[1]  # number of rows ie samples
save(gs_sample_data,file=paste(out_dir,"/",project_name,".gs_sample_data.RData",sep="") )

#  pheno_file
if(is.na(pheno_file))  stop(" WARNING!: YOU HAVENT PROVIDED ANY PHENOTYPE INFORMATION!!!" )
pheno_file

pheno_dat <- read.table(paste(pheno_file), as.is=T,fill=T,head=T,sep="\t")
save(pheno_dat,file=paste(out_dir,"/",project_name,".pheno_dat.RData",sep="") )
has_pheno_cols <- c("Sample.ID","SEX","GROUPS","TISSUE","PHENOTYPE","Study_ID") %in% names(pheno_dat);
missing_pheno_cols <- "FALSE" %in% has_pheno_cols
if(missing_pheno_cols == "TRUE") stop(" WARNING!: YOU ARE MISSING ESSENTIAL SAMPLE INFORMATION! MAKE SURE YOUR PHENO_FILE HAS:- Sample.ID,SEX,GROUPS,TISSUE,PHENOTYPE,Study_ID !!!")
raw_n_pheno_dat <- dim(pheno_dat)[1] # number of rows ie samples

# tech_pheno_file
if(is.na(tech_pheno_file))  stop(" WARNING!: YOU HAVENT PROVIDED ANY BATCH INFORMATION!!!" )
tech_pheno_file

tech_pheno <- read.table(paste(tech_pheno_file),head=T,sep="\t")
tech_pheno$Sentrix.Barcode <- as.character(tech_pheno$Sentrix.Barcode)
colnames(tech_pheno) <- paste("tech.",names(tech_pheno),sep="")
colnames(tech_pheno) <- c("Sample.ID", names(tech_pheno[,-1]))
save(tech_pheno,file=paste(out_dir,"/",project_name,".tech_pheno.RData",sep="") )

# get pData()
eset_samples <- pData(eset_raw)
# add chip order and flad for "has expression data" to eset_samples (pData)
eset_samples$has_expression <- 1
eset_samples$chip_order <- 1:dim(eset_samples)[1]
save(eset_samples,file=paste(out_dir,"/",project_name,".eset_samples.RData",sep="") )

# col names
names(eset_samples) 
names(gs_sample_data)
names(pheno_dat)
names(tech_pheno)

# quick check
# these should all have the same number of rows or samples!
dim(eset_samples);dim(gs_sample_data);dim(pheno_dat);dim(tech_pheno)

# Venn of Sample.ID
ex <- eset_samples$sampleID
pp <- pheno_dat$Sample.ID
tt <- tech_pheno$Sample.ID
venninput  <-list(ArrayExpression=ex,Batch_Info=tt,Pheno_Info=pp)
venn(venninput)
dev.off()

```

## 3. check eset_samples, sample & batch info Sample.ID's match in names and numbers & merge all
```{r MatchSamplePhenoAndBatchInfo, eval=TRUE}

# 1. merge eset_samples with pheno_dat. 
# Keep ALL overlaps only
eset_pheno_merge <- merge(eset_samples,pheno_dat,by.x="sampleID",by.y="Sample.ID" )
eset_pheno_merge <- eset_pheno_merge[order(eset_pheno_merge$chip_order),]
dim(eset_samples);dim(eset_pheno_merge) # check size

# 2. merge eset_pheno_merge with tech_pheno
eset_pheno_batch_merge <- merge(eset_pheno_merge,tech_pheno,by.x="sampleID",by.y="Sample.ID" )
eset_pheno_batch_merge <- eset_pheno_batch_merge[order(eset_pheno_batch_merge$chip_order),]
dim(eset_samples);dim(eset_pheno_merge);dim(eset_pheno_batch_merge) # check size

# 3. merge all with genomestudio final report
eset_pheno_batch_gs_merge <- merge(eset_pheno_batch_merge,gs_sample_data,by.x="sampleID",by.y="Sample.ID" )
eset_pheno_batch_gs_merge <- eset_pheno_batch_gs_merge[order(eset_pheno_batch_gs_merge$chip_order),]

# final look at numbers in each merged data set
dim(eset_samples);dim(eset_pheno_merge);dim(eset_pheno_batch_merge);dim(eset_pheno_batch_gs_merge)

# names
names(eset_pheno_batch_gs_merge)

```

## 4. Subset raw ExpressionSet to matched/complete Sample.IDs & Update pData() slot.
```{r subsetEsetRaw, eval=TRUE}

# samples in gene expression data
samples_eset <- pData(eset_raw)$sampleID
length(samples_eset)

# samples with complete data
samples_complete_data <- eset_pheno_batch_gs_merge$sampleID
length(samples_complete_data)  

# samples to remove
samples_to_remove <- (samples_eset %in% samples_complete_data)==FALSE  
samples_to_remove <- pData(eset_raw)$sampleID[samples_to_remove]
length(samples_to_remove)  
  
# rename eset_raw & save
eset_raw_preqc <- eset_raw
save(eset_raw_preqc, file=paste(out_dir,"/",project_name,".eset_raw_preqc.RData",sep=""))

# subset eset_raw
eset_raw <- removeSamples_eset_lumi(eset=eset_raw_preqc,sampleRemove=samples_to_remove)
eset_raw

# update pData
old_pdata <- pData(eset_raw)
old_pdata$old_order <- 1:dim(old_pdata)[1]

# merge with eset_pheno_batch_gs_merge
new_pdata <- merge(old_pdata, eset_pheno_batch_gs_merge, by.x="sampleID", by.y="sampleID", all=TRUE,sort=FALSE)
new_pdata <- new_pdata[order(new_pdata$old_order),]

# remove columns old_order has_expression chip_order
new_pdata <- new_pdata[,-c(2,3,4)]

# update rownames
rownames(new_pdata) <- new_pdata$sampleID

# update pData slot
pData(eset_raw) <- new_pdata
dim(pData(eset_raw))

eset_raw # varLabels: sampleID SEX ... Noise (43 total)

```

## 5. Add nuID to fData
```{r updateFeatureData, eval=TRUE}
 #Add nuID to fData
fData(eset_raw)$nuID <- rownames(fData(eset_raw))
head(fData(eset_raw))
```

## 6. Save updated raw ExpressionSet eset_raw
```{r saveEsetRaw, eval=TRUE}
# Save updated raw ExpressionSet eset_raw
save(eset_raw, file=paste(out_dir,"/",project_name,".eset_raw.RData",sep=""))
```

## 7. Write data files to out_dir for eset_raw
```{r writeEsetRawData, eval=TRUE}
# Write data files to out_dir for eset_raw
write_expression_files(eset=eset_raw,outfile=paste(out_dir,"/",project_name,".eset_raw",sep="") )
```

## 8. Basic QC and plots on eset_raw
```{r basicQCplots, eval=TRUE}
# Basic Plots
    chip_col <- labels2colors( as.character(pData(eset_raw)$Sentrix.Barcode))
    plot(eset_raw, what='boxplot', col=chip_col )
    plot(eset_raw, what='density' )
    plot(eset_raw, what='cv'  )
    plot(eset_raw, what='outlier'  )
# flashClust
  datExprs <- exprs(eset_raw)
  dist_exprs <- dist( t(datExprs), method="e" )
  sampleTree <- flashClust( dist_exprs, method = "average");
  plot(sampleTree)
```

## 9. SampleNetwork on all samples as a first pass
```{r SampleNetwork_eset_raw, eval=TRUE}
# SampleNetwork on all samples as a first pass
samle_names <- sampleNames(eset_raw)
IAC=cor(datExprs, method="p",use="p")
diag(IAC)=0
A.IAC=((1+IAC)/2)^2  ## ADJACENCY MATRIX
FNC=fundamentalNetworkConcepts(A.IAC) ## WGCNA
K2=FNC$ScaledConnectivity
Z.K=(K2-mean(K2))/sd(K2)
Z.C=(FNC$ClusterCoef-mean(FNC$ClusterCoef))/sd(FNC$ClusterCoef)
Z.MAR=(FNC$MAR-mean(FNC$MAR))/sd(FNC$MAR)
rho <- signif(cor.test(Z.K,Z.C,method="s")$estimate,2)
rho_pvalue <- signif(cor.test(Z.K,Z.C,method="s")$p.value,2)
colorvec <- colorvec <- labels2colors(as.character(pData(eset)$Sentrix.Barcode))
## OUTLIERS
Z.K_outliers <- Z.K < -sd_thrs
Z.K_outliers <- names(Z.K_outliers[Z.K_outliers==TRUE])
n_outliers <- length(Z.K_outliers)
mean_IAC <- mean(IAC[upper.tri(IAC)])
min_Z.K <- min(Z.K)
cat(" Number of Z.K outliers [", n_outliers,"]","\r","\n")
cat(" mean_IAC [", mean_IAC,"]","\r","\n")
#
local( 
  {colLab <<- function(n,treeorder) { 
    if(is.leaf(n)) {
      a <- attributes(n)
      i <<- i+1
      attr(n, "nodePar") <-   c(a$nodePar, list(lab.col = colorvec[treeorder][i], lab.font = i%%3))
      }
    n
    }
   i <- 0
   })
## Cluster for pics
meanIAC <- mean(IAC[upper.tri(IAC)],na.rm=T)
cluster1 <- hclust(as.dist(1-A.IAC),method="average")
cluster1order <- cluster1$order
cluster2 <- as.dendrogram(cluster1,hang=0.1)
cluster3 <- dendrapply(cluster2,colLab,cluster1order)
## PLOTS
## cluster IAC
par(mfrow=c(2,2))
par(mar=c(5,6,4,2))
plot(cluster3,nodePar=list(lab.cex=1,pch=NA),main=paste("Mean ISA = ",signif(mean(A.IAC[upper.tri(A.IAC)]),3),sep=""),xlab="",ylab="1 - ISA",sub="",cex.main=1.8,cex.lab=1.4)
mtext(paste("distance: 1 - ISA ",sep=""),cex=0.8,line=0.2)
## Connectivity
par(mar=c(5,5,4,2))
plot(Z.K,main="Connectivity", ylab="Z.K",xaxt="n",xlab="Sample",type="n",cex.main=1.8,cex.lab=1.4)
text(Z.K,labels=samle_names,cex=0.8,col=colorvec)
abline(h=-2)
abline(h=-3)
## ClusterCoef
par(mar=c(5,5,4,2))
plot(Z.C,main="ClusterCoef", ylab="Z.C",xaxt="n",xlab="Sample",cex.main=1.8,cex.lab=1.4,type="n")
text(Z.C,labels=samle_names,cex=0.8,col=colorvec)
abline(h=-2)
abline(h=-3)
## Connectivity vs ClusterCoef
par(mar=c(5,5,4,2))
plot(Z.K,Z.C,main="Connectivity vs ClusterCoef",xlab="Z.K",ylab="Z.C",col=colorvec,cex.main=1.8,cex.lab=1.4)
abline(lm(Z.C~Z.K),col="black",lwd=2)
mtext(paste("rho = ",signif(cor.test(Z.K,Z.C,method="s")$estimate,2)," p = ",signif(cor.test(Z.K,Z.C,method="s")$p.value,2),sep=""),cex=0.8,line=0.2)
abline(v=-2,lty=2,col="grey")
abline(h=-2,lty=2,col="grey")
#
dev.off()
```

## 10. Some more advanced QC plots & PCA with Batch variables
```{r qc_plots_eset_raw, eval=TRUE}
# Some more advanced QC plots & PCA with Batch variables
# PCA Plots, heatmaps and SampleNetwork Z.K plots
# Review these manually
gx_qc_plots_lumi(eset=eset_raw, outfile=paste(out_dir,"/",project_name,".eset_raw",sep="") )

```

***********************************************************************************************************************************************************

MBCB (Model-based Background Correction for Beadarray)
-------------------------------------------------------

## 1. Run mbcb.correct(signal,negCon,npBool=FALSE,mleBool=TRUE,isRawBead=FALSE)
```{r runMBCB, eval=TRUE}
# Run Model-based Background Correction for Beadarray : method = MLE
# mbcb.correct(signal,negCon,npBool=FALSE,mleBool=TRUE, isRawBead=FALSE)
eset_bg <- bgcor_mbcb(eset=eset_raw, outfile=paste(out_dir,"/",project_name,".eset_bg",sep="") )
eset_bg 
```

## 2. SAVE BACKGROUND CORRECTED DATA 
```{r save_eset_bg, eval=TRUE}
save(eset_bg, file=paste(out_dir,"/",project_name,".eset_bg.RData",sep="")  , compress=T)
```

## 3. Write data files to out_dir for eset_bg
```{r write_eset_bg_Data, eval=TRUE}
# Write data files to out_dir for eset_raw
write_expression_files(eset=eset_bg,outfile=paste(out_dir,"/",project_name,".eset_bg",sep="") )

# NB: SKIP QC PLOTS ETC. Not really needed at this point
```

***********************************************************************************************************************************************************
Id Detected Probes per GROUPS
-------------------------------------------------------
```{r id_detected_probes_per_group, eval=TRUE}
## PROBE DETECTED 2SD ABOVE MEAN BACKGROUND ##
cat(" Calculating Probe Detection rates. \n Probe is seen as Detected if it has background corrected signal intensity >= 2SD of the mean intensity of the negative control beads","\r","\n")
## get expression matrix
gx <- exprs(eset_bg)
## get negative bead ranges mean or max or >2SD mean  of neg beads
neg_2sd <- neg_mean + 2*neg_sd
## sweep through gx matrix to id probes > 2SD Mean of negative beads
det <- sweep(gx, 1, neg_2sd,">=")
## Writing Probe Detection Calls to file #
det_tmp  <- as.data.frame(det)
det_tmp$nuID <- rownames(det_tmp)
probe_detected <- merge(fData(eset_bg), det_tmp , by.x="nuID",by.y="nuID",sort=FALSE)
cat(" Writing Probe Detection Calls to",paste(out_dir,"/",project_name,".eset_bg.probe_detected.txt",sep="") ,"\r","\n")
write.table(probe_detected , file=paste(out_dir,"/",project_name,".eset_bg.probe_detected.txt",sep=""),sep="\t",row.names=FALSE, quote=FALSE)
rm("det_tmp")
## probe_detection counts
probe_detection <- rowSums(det)
## n samples
n_samples <- dim(gx)[2]
## probe annotations
probes_not_detected_in_any_sample <- probe_detection==0
probes_detected_in_80_sample <- probe_detection>=n_samples*0.80
probes_detected_in_all_sample <- probe_detection==n_samples
probe_annotations_0_detected <- fData(eset_bg[probes_not_detected_in_any_sample,])
probe_annotations_80_detected  <- fData(eset_bg[probes_detected_in_80_sample ,])
probe_annotations_100_detected  <- fData(eset_bg[probes_detected_in_all_sample,])
cat(" Adding detetion call rate for all probes and samples to fData() slot for eset_bg","\r","\n")
fData(eset_bg)$n_detected <- probe_detection
fData(eset_bg)$n_detected_call_rate <- round( probe_detection/n_samples ,3)
## sample_detection counts
n_probes <- dim(eset_bg)[1]
sample_detection <- colSums(det)
pData(eset_bg)$n_probes_detected <- sample_detection
pData(eset_bg)$n_probes_detected_call_rate <- round( sample_detection/n_probes ,3)
save(eset_bg, file=paste(out_dir,"/",project_name,".eset_bg.RData",sep=""))
## get group information from pData() slot
group_names <- unique(pData(eset_bg)$GROUPS);
groups  <- pData(eset_bg)$GROUPS
n_groups <- length(group_names)
## get expression matrix ##
gx <- exprs(eset_bg)
neg_2sd <- as.numeric(neg_2sd)

## loop through each group and id probes > 2SD mean neg beads in X% of samples/group
for(n in group_names ) {
cat(" Finding probes in ",probe_det," of sample group [",n,"] with signal intensity >= 2SD mean intensity of the negative control beads ","\r","\n")
group_label <- paste(n)
sel_samples <- pData(eset_bg)$GROUPS==n;
n_samples_in_group <- dim(gx[,sel_samples])[2];
cat(" Number of samples in group [",n,"] = ",n_samples_in_group,"\r","\n")
detection_matrix <- sweep(gx[,sel_samples],1,neg_2sd[sel_samples],">=")
group_probe_detection <- rowSums(detection_matrix) >= (probe_det/100)*n_samples_in_group
group_probe_detection_nuID <- rownames( gx[group_probe_detection==TRUE, ])
cat(" Number of probes in group [",n,"] with signal intensity >= 2SD mean intensity of the negative control beads = ", length(group_probe_detection_nuID) ,"\r","\n")
cat(" Writing probe list to ",paste(out_dir,"/",project_name,".GROUP.",group_label,".detected_probes_nuID.txt",sep=""), "\r","\n" )
det_probes <- as.data.frame(group_probe_detection_nuID)
colnames(det_probes) <- c("nuID")
write.table( det_probes ,file=paste(out_dir,"/",project_name,".GROUP.",group_label,".detected_probes_nuID.txt",sep=""),row.names=FALSE,quote=FALSE,col.names=FALSE)
}

## Y CHROM EXPRESSION IN XIST MALES
cat(" Y Chromosome probe detection based on XIST males","\r","\n")
xist_males <- pData(eset_bg)$xist_gender=="Male"
gx_y <- exprs(eset_bg[fData(eset_bg)$CHR=="Y",])
detection_matrix_y <- sweep( gx_y[,xist_males],1, neg_2sd[xist_males ],">=")
y_probe_detection <- rowSums(detection_matrix_y) >= probe_det * sum(xist_males==TRUE)
y_probe_detection_nuID <- rownames( gx_y[y_probe_detection, ])
y_det_probes <- as.data.frame(y_probe_detection_nuID)
colnames(y_det_probes) <- c("nuID")
write.table( y_det_probes ,file=paste(out_dir,"/",project_name,".GROUP.Y.detected_probes_nuID.txt",sep=""),row.names=FALSE,quote=FALSE,col.names=FALSE)

## writing final good probe list
cat(" writing final good probe list to ",paste(out_dir,"/",project_name,".detected_probes_nuID_final.txt",sep=""),"\r","\n")
system(paste("cat ",out_dir,"/",project_name,"****.detected_probes_nuID.txt | sort | uniq >> ",out_dir,"/",project_name,".detected_probes_nuID_final.txt", sep="") )
good_probes <- read.table(file=paste(out_dir,"/",project_name,".detected_probes_nuID_final.txt",sep=""),head=FALSE)
good_probes <- paste(good_probes[,1])
n_good_probes <- length(good_probes)
cat(" Total number of good probes = ",n_good_probes,"\n","\r" )
good_probes_annotation <- fData(eset_bg[paste(good_probes,sep=""),])
good_probes_annotation$raw_mean <- apply( exprs(eset_bg[good_probes,]), 1,mean)
good_probes_annotation$raw_sd <- apply( exprs(eset_bg[good_probes,]), 1,sd)
good_probes_annotation$raw_var <- apply( exprs(eset_bg[good_probes,]), 1,var)
good_probes_annotation$raw_min <- apply( exprs(eset_bg[good_probes,]), 1,min)
good_probes_annotation$raw_max <- apply( exprs(eset_bg[good_probes,]), 1,max)
head(good_probes_annotation)
cat(" saving good probe annotations to ",paste(out_dir,"/",project_name,".detected_probes_nuID_final.***",sep=""),"\r","\n")
save(good_probes_annotation, file=paste(out_dir,"/",project_name,".detected_probes_nuID_final.RData",sep="") )
write.table(good_probes_annotation, file=paste(out_dir,"/",project_name,".detected_probes_nuID_final.txt",sep=""),quote=F,sep="\t",row.names=F )
```

***********************************************************************************************************************************************************
Check Gender based on XIST gene expression
-------------------------------------------------------
```{r checkGender, eval=TRUE}
cat(" Checking Gender based on XIST gene expression","\r","\n")
## get neg control data from eset_bg
negativeControl <- getControlData(eset_bg)
negativeControl <- subset(negativeControl, negativeControl$controlType=="NEGATIVE")
negativeControl <- negativeControl[,c(3:dim(negativeControl)[2])]
## get neg control info mean,sd,max etc
neg_max <- apply(negativeControl,2,max)
neg_sd <- apply(negativeControl,2,sd)
neg_mean <- apply(negativeControl,2,mean)
neg_2sd <- neg_mean + 2*neg_sd
## get XIST gene postion
xist_raw <- fData(eset_raw)$ILMN_GENE=="XIST";
xist_bkcor <- fData(eset_bg)$ILMN_GENE=="XIST";
## get XIST gene expression signal
xist_gx_raw  <- exprs(eset_raw[xist_raw, ]  )
xist_gx_raw <- as.data.frame( t(xist_gx_raw));
xist_gx_bkcor <- exprs(eset_bg[xist_bkcor , ]  )
xist_gx_bkcor <- as.data.frame( t(xist_gx_bkcor));
## cobine raw and bkCro gx data
xist_gx <- cbind(xist_gx_raw,xist_gx_bkcor)
colnames(xist_gx) <- c("raw_XIST","bkcor_XIST")
xist_gx$neg_2sd <- neg_2sd
xist_gx$neg_max <- neg_max
xist_gx$neg_mean <- neg_mean
xist_gx$neg_sd <- neg_sd
## gender based on XIST expression 1=female , 0 = male
xist_gx$XIST_Gender_max <- ifelse(xist_gx$bkcor_XIST > xist_gx$neg_max,1,0)
xist_gx$XIST_Gender_2sd <- ifelse(xist_gx$bkcor_XIST > xist_gx$neg_2sd,1,0)  # THIS WORKS!! IF GENE IS > 2SD_NEG_BEAD THEN ITS EXPRESSED/DETECTED!
xist_gx$XIST_z <-  ( xist_gx$bkcor_XIST - xist_gx$neg_mean ) / xist_gx$neg_sd
xist_gx$Sample.ID <- rownames(xist_gx)
# illumina detection p value for xist
xist_gx$xist_illumina_detection_p <- as.numeric(detection(eset_bg[fData(eset_bg)$ILMN_GENE=="XIST",]))
xist_gx$xist_illumina_detection_p <- ifelse( xist_gx$xist_illumina_detection_p  == 0.00000, 0.00001,xist_gx$xist_illumina_detection_p )
# gender based on bg cor expression > 2SD negatibe beads
xist_gx$xist_gender <- ifelse(xist_gx$bkcor_XIST > xist_gx$neg_2sd,"Female","Male")
# gender provided in database
xist_gx$clinical_gender <- pData(eset_bg)$SEX
# gender based on illumina detecetion p value
xist_gx$xist_illumina_detection_p_gender <- ifelse(xist_gx$xist_illumina_detection_p <= 0.01,"Female","Male") ## 0.05 makes them all female!
# flag gender missmatch
xist_gx$gender_missmatch <- ifelse( xist_gx$xist_gender == xist_gx$clinical_gender, "PASS","GENDER_MISSMATCH" )
xist_gx$gender_missmatch_illumina_detection_p <- ifelse( xist_gx$xist_illumina_detection_p_gender == xist_gx$clinical_gender, "PASS","GENDER_MISSMATCH" )
# head
head(xist_gx)
# table SEX
table(xist_gx$clinical_gender);
table(xist_gx$xist_gender);
table(xist_gx$xist_illumina_detection_p_gender);
# tables SEX compare
table(xist_gx$xist_gender, xist_gx$clinical_gender);
table(xist_gx$xist_illumina_detection_p_gender, xist_gx$clinical_gender);
# Density plots with semi-transparent fill of SEX CALLS
df <- xist_gx[,c("bkcor_XIST", "clinical_gender", "xist_gender", "xist_illumina_detection_p_gender")]
head(df)
# Find the mean of each group
# library(plyr)
cdf_clinical_gender <- ddply(df, "clinical_gender", summarise, mean=mean(log2(bkcor_XIST)))
cdf_xist_gender <- ddply(df, "xist_gender", summarise, mean=mean(log2(bkcor_XIST)))
cdf_xist_illumina_detection_p_gender <- ddply(df, "xist_illumina_detection_p_gender", summarise, mean=mean(log2(bkcor_XIST)))
cdf_clinical_gender
cdf_xist_gender 
cdf_xist_illumina_detection_p_gender
# ggplots
ggplot(df, aes(x=log2(bkcor_XIST), fill=clinical_gender )) + geom_histogram(binwidth=.5, alpha=.5, position="identity")
ggplot(df, aes(x=log2(bkcor_XIST), fill=xist_gender )) + geom_histogram(binwidth=.5, alpha=.5, position="identity")
ggplot(df, aes(x=log2(bkcor_XIST), fill=xist_illumina_detection_p_gender )) + geom_histogram(binwidth=.5, alpha=.5, position="identity")
# Box plots With flipped axes
ggplot(df, aes( y=log2(bkcor_XIST), x=clinical_gender, fill=clinical_gender)) + geom_boxplot() +  guides(fill=FALSE) + coord_flip()
ggplot(df, aes( y=log2(bkcor_XIST), x=xist_gender, fill=xist_gender)) + geom_boxplot() +  guides(fill=FALSE) + coord_flip()
ggplot(df, aes( y=log2(bkcor_XIST), x=xist_illumina_detection_p_gender, fill=xist_illumina_detection_p_gender)) + geom_boxplot() +  guides(fill=FALSE) + coord_flip()
# save plots to pdf
pdf(file=paste(out_dir,"/",project_name,".eset_bg.XIST.Gender_plot.pdf",sep=""),height=8,width=11)
# some plots 
boxplot( log2(bkcor_XIST) ~ clinical_gender, data=xist_gx, main="bg XIST.gx ~ clinical_gender")
boxplot( log2(bkcor_XIST) ~ xist_gender, data=xist_gx, main="bg XIST.gx ~ xist_gender")
boxplot( log2(bkcor_XIST) ~ xist_illumina_detection_p_gender, data=xist_gx, main="bg XIST.gx ~ xist_illumina_detection_p_gende")
plot(log2(xist_gx$bkcor_XIST), type="p", col=2+xist_gx$XIST_Gender_2sd, pch=19 , cex=0.6);
points(log2(xist_gx$neg_2sd),col="blue", type="l")
plot(xist_gx$bkcor_XIST, type="p", col=2+xist_gx$XIST_Gender_2sd, pch=19 , cex=0.6);
points(xist_gx$neg_2sd,col="blue", type="l")
dev.off()

# save xist_gx data
save(xist_gx, file=paste(out_dir,"/",project_name,".eset_bg.XIST.Gender.RData",sep=""))
write.table(xist_gx, file=paste(out_dir,"/",project_name,".eset_bg.XIST.Gender.txt",sep=""),sep="\t",row.names=F)
## check sex and add to pData

pheno_update <- merge(pData(eset_bg), xist_gx, by.x="sampleID", by.y="Sample.ID",all.x=TRUE,sort=FALSE)
rownames(pheno_update) <-  pheno_update$sampleID
pData(eset_bg) <- pheno_update
save(eset_bg, file=paste(out_dir,"/",project_name,".eset_bg.RData",sep=""))
# n_gender_fails
n_gender_fails <- sum( pData(eset_bg)$gender_missmatch=="GENDER_MISSMATCH" )
if ( n_gender_fails > 0 ) {
    cat(" WARNING: Youn have GENDER_MISSMATCH samples!!!!!!! N=[",n_gender_fails,"]","\r","\n")
} else {
  cat(" Congratulations! \n All your Males are Male and Females are Female. \n You have NO GENDER_MISSMATCH samples!!!", "\r","\n")
}
## write file of sex fails
gender_missmatch_table <- subset(pData(eset_bg),pData(eset_bg)$gender_missmatch=="GENDER_MISSMATCH")
write.table(gender_missmatch_table, file=paste(out_dir,"/",project_name,".eset_bg.XIST.gender_missmatch_table.txt",sep=""),sep="\t",row.names=F)
## SAVE BACKGROUND CORRECTED DATA sex checked 
pData(eset_bg)$GROUPS <- toupper(pData(eset_bg)$GROUPS) ## added as an extra check for those pesky "case" issues!
pData(eset_bg)$PHENOTYPE <- toupper(pData(eset_bg)$PHENOTYPE)
save(eset_bg, file=paste(out_dir,"/",project_name,".eset_bg.RData",sep="")  , compress=T)
cat(" Writing eset_bg [beadNum, detection, exprs, se.exprs] data to file ", paste(out_dir,"/",project_name,".eset_bg.[beadNum, detection, exprs, se.exprs].txt",sep=""), "\r","\n")
write_expression_files(eset=eset_bg,outfile= paste(out_dir,"/",project_name,".eset_bg",sep="") )
```

***********************************************************************************************************************************************************

Transform and Normalise
-------------------------------------------------------
See **Comparison of normalization methods for Illumina BeadChip HumanHT-12 v3**
BMC Genomics. 2010; 11: 349. Ramona Schmid et al
http://www.pubmedcentral.nih.gov/articlerender.fcgi?artid=3091625&tool=pmcentrez&rendertype=abstract
Figure 10 Pearson correlation of log2 ratios for different normalization methods and qRT-PCR. 
This study selects bg_rma_log_rsn as the best.
Here we have used a better method for background correction, followed by log2 transformation and robust-splince normalisation (rsn).
The robust spline normalization (RSN) algorithm combines the features of quantile and loess normalization.

```{r lumiExpresso, eval=TRUE}
# See Comparison of normalization methods for Illumina BeadChip HumanHT-12 v3.
# BMC Genomics. 2010; 11: 349.
# Ramona Schmid et al
# Figure 10 Pearson correlation of log2 ratios for different normalization methods and qRT-PCR. 
# This study selects bg_rma_log_rsn as the best
# http://www.pubmedcentral.nih.gov/articlerender.fcgi?artid=3091625&tool=pmcentrez&rendertype=abstract

# log2 > rsn
eset_bg_log2_rsn_0 <- lumiExpresso(eset_bg, bg.correct = FALSE,
                                      variance.stabilize=TRUE, varianceStabilize.param=list(method='log2'), 
                                      normalize.param=list(method='rsn'), verbose=FALSE);
# save log2 > rsn
save(eset_bg_log2_rsn_0, file=paste(out_dir,"/",project_name,".eset_bg_log2_rsn_0.RData",sep="")  , compress=T)
# QC Plots of Transformed and Normalised data 
gx_qc_plots_lumi(eset=eset_bg_log2_rsn_0, outfile=paste(out_dir,"/",project_name,".eset_bg_log2_rsn_0",sep="") )
# write_expression_files
write_expression_files(eset=eset_bg_log2_rsn_0,outfile= paste(out_dir,"/",project_name,".eset_bg_log2_rsn_0",sep="") )
```

SampleNetwork : Id outlier samples 
-------------------------------------------------------
Adapted from : Network methods for describing sample relationships in genomic datasets: application to Huntington's disease. Michael C Oldham et al.
BMC Syst Biol. 2012; 6: 63.
http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3441531/?tool=pmcentrez&report=abstract
```{r basic_sampleNetworkIterate, eval=TRUE}
# Id outlier samples
# Adapted from : Network methods for describing sample relationships in genomic datasets: application to Huntington's disease. Michael C Oldham et al.
# BMC Syst Biol. 2012; 6: 63.
# http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3441531/?tool=pmcentrez&report=abstract
# Oginal Code : 

# basic_sampleNetworkIterate
ISAoutliers <- basic_sampleNetworkIterate(eset=eset_bg_log2_rsn_0,
                                          col_by_chip=0, 
                                          groups="byGroup" ,
                                          outfile=paste(out_dir,"/",project_name,".eset_bg_log2_rsn_0.",sep=""), 
                                          IACthresh=0.95, 
                                          sd_thrs=2 );

# Outliers
outlier_samples <- ISAoutliers$iac_outlier_samples
cat(" number of outlier samples =", length(outlier_samples),"/",dim(eset_bg)["Samples"],"=",length(outlier_samples)/dim(eset_bg)["Samples"],"\r","\n")
save(outlier_samples, file=paste(out_dir,"/",project_name,".eset_bg_log2_rsn_0_outlier_samples.RData",sep="") )
```

SampleNetwork : Remove outlier samples 
-------------------------------------------------------
```{r removeISAoutlers, eval=TRUE}
# remove outlier_samples
eset_bg_log2_rsn <- removeSamples_eset_lumi(eset=eset_bg_log2_rsn_0,sampleRemove=outlier_samples)
eset_bg_log2_rsn
save(eset_bg_log2_rsn, file=paste(out_dir,"/",project_name,".eset_bg_log2_rsn.RData",sep="")  , compress=T)
```

QC Plots of Transformed and Normalised data after outlier removal
------------------------------------------------------------------
```{r qcPlots_eset_bg_log2_rsn, eval=TRUE}
# QC Plots of Transformed and Normalised data 
gx_qc_plots_lumi(eset=eset_bg_log2_rsn, outfile=paste(out_dir,"/",project_name,".eset_bg_log2_rsn",sep="") )
# write_expression_files
write_expression_files(eset=eset_bg_log2_rsn,outfile= paste(out_dir,"/",project_name,".eset_bg_log2_rsn",sep="") )
```

***********************************************************************************************************************************************************

PCA Batch Regressions
-------------------------------------------------------
making this a requirement ie if [tech_pheno_file] then do this
test for assoc of PHENO with PC1 and batches

## 1. Set up data for batch regressions
```{r start_PCA_Batch_Regressions, eval=FALSE}
eset_lumiN <- eset_bg_log2_rsn # a little fix
cat(" Starting batch versus PC1 and PHENOTYPE Rregressions [PC1 ~ batch_var]","\r")
cat(" Getting Gene expression matrix ","\n","\r")
gx <- exprs(eset_lumiN)
gx <- t(gx)
cat(" Reading in technical information on eg [Sample.ID, RIN, RNA_YIELD, BATCH, CHIP, DATE_CHIP_RUN, DATE_RNA_EXTRACTED] ",tech_pheno_file ,"\r")
tech_pheno <- read.table(paste(tech_pheno_file),head=TRUE,sep="\t") ## Sample.ID,RIN,RNA_YIELD,BATCH,CHIP, DATE_CHIP_RUN,DATE_RNA_EXTRACTED
tech_pheno$Sentrix.Barcode <- as.factor(tech_pheno$Sentrix.Barcode)
pdata <- pData(eset_lumiN)
pdata <- as.data.frame(pdata[,c("sampleID","Index")])
colnames(pdata) <- c("sampleID","Index")
tech_pheno <- merge( pdata, tech_pheno, by.x="sampleID", by.y="Sample.ID", sort=FALSE, all.x=TRUE)
tech_batch <- tech_pheno[,3:dim(tech_pheno)[2]]
head(tech_batch)
# get names of var
cat(" get names of var ","\r")
batch_var_names <- names(tech_batch)
date_vars <- grep("Date",batch_var_names) # which ones are dates
batch_var_names
## Run PCA
cat(" Running PCA on t(exprs(eset)) ","\r")
pca_gx <- prcomp(gx)$x
pca_gx <- pca_gx[,"PC1"]
# PHENOTYPES FOR REGRESSIONS
cat(" setting up phenotypes PC1,PHENOTYPE & GROUPS for regressions ","\r")
PC1 <- as.numeric(pca_gx)
PHENOTYPE <- as.numeric(as.factor(pData(eset_lumiN)$PHENOTYPE))
GROUPS <-    as.numeric(as.factor(pData(eset_lumiN)$GROUPS))
#
df <- cbind(tech_batch,PC1,PHENOTYPE,GROUPS)
df_z <- apply(df,2,as.factor)
df_z <- apply(df_z,2,as.numeric)
```

## 2. multivariate model
```{r multivariate_model_PCA_Batch_Regressions, eval=FALSE}
# Test for association of batch vars with PC1
# multivariate full model
multivariate_model_terms <- paste(batch_var_names ,collapse="+")

for(pheno in c("PHENOTYPE","GROUPS","PC1") ) {
  # make model for lm
  multivariate_model <- paste(pheno,"~",multivariate_model_terms,sep="") ## prot ~ c1+c2+c3...
  multivariate_model <- as.formula(multivariate_model)
  # multivariate lm
  cat(" running full multivariate models ",pheno," ~ multivariate_model ", "\r","\n")
  lm_batch <- lm(multivariate_model, data=tech_batch)
  # RSQUARED summary lm
  lm_r2 <- round( summary(lm_batch)$adj.r.squared, 3)
  # summary lm
  summary_lm_batch <- summary(lm_batch)$coef
  summary_lm_batch <- as.data.frame(summary_lm_batch)
  summary_lm_batch$terms <- rownames(summary_lm_batch)
  summary_lm_batch$significant <- ifelse(summary_lm_batch$"Pr(>|t|)"<=0.05,1,0)
  summary_lm_batch$model_rsq <- lm_r2
  # save summary lm
  write.table(summary_lm_batch , file=paste(out_dir,"/",project_name,".eset_bg_log2_rsn.",pheno,".multivariate_model_batch_variables.csv",sep=""),row.names=FALSE,quote=FALSE, sep=",")
  # multivariate ANOVA
  anova_lm_batch <- anova(lm_batch)
  anova_lm_data <- as.data.frame(anova_lm_batch)
  anova_lm_data$terms <- rownames(anova_lm_data)
  anova_lm_data <- subset(anova_lm_data, anova_lm_data$terms!="Residuals")
  ## plot ANOVA P
  par(mar=c(10,5,4,2))
  barplot(-log10(anova_lm_data $"Pr(>F)"), srt=45,las=3, names=c(anova_lm_data$terms) , ylab="ANOVA -log10(P)", main=paste("multivariate_model. R2=",lm_r2,sep=""),cex.names=0.8,cex.main=0.8,cex.lab=1)
  abline(h=-log10(0.05),col="blue")
  abline(h=-log10(0.05/dim(anova_lm_data)[1]),col="red")
  ## plot to pdf
  pdf(file=paste(out_dir,"/",project_name,".eset_bg_log2_rsn.",pheno,".ANOVA_multivariate_model_batch_variables.pdf",sep=""), width=8,height=6 )
  par(mar=c(10,5,4,2))
  barplot(-log10(anova_lm_data $"Pr(>F)"), srt=45,las=3, names=c(anova_lm_data$terms) , ylab="ANOVA -log10(P)", main=paste(pheno,"~ multivariate_model. R2=",lm_r2,sep=""),cex.names=0.8,cex.main=0.8,cex.lab=1)
  abline(h=-log10(0.05),col="blue")
  abline(h=-log10(0.05/dim(anova_lm_data)[1]),col="red")
  dev.off()
  ## save ANOVA
  write.table(anova_lm_data , file=paste(out_dir,"/",project_name,".eset_bg_log2_rsn.",pheno,".ANOVA_multivariate_model_batch_variables.csv",sep=""),row.names=FALSE,quote=FALSE, sep=",")
  
# are there any sig ANOVA terms
min_anova_p <- min(anova_lm_data$"Pr(>F)")
  
# if so then do this:-
if(min_anova_p <= 0.05) {
  sig_anova_lm_data <- subset(anova_lm_data, anova_lm_data$"Pr(>F)"<=0.05)
  most_sig_term <- sig_anova_lm_data$terms[sig_anova_lm_data$"Pr(>F)"==min_anova_p]
  sig_terms <- sig_anova_lm_data$terms
  sig_terms <- paste(sig_terms ,collapse=" + ")
  cat(" WARNING!: SIGNIFICANT ASSOCIATION BETWEEN [ ",pheno," ] ~ [",sig_terms," ]. R2=",lm_r2 ," [",most_sig_term,"] MIN_P=",min_anova_p,". YOU MAY WANT TO CORRECT FOR THIS BEFORE THE FINAL ANLYSIS ","\r","\n")
  ## STEP find best terms
  cat(" Finding a best model by AIC in a Stepwise Algorithm ","\r","\n" )
  step_lm_batch <- stepAIC(lm_batch,direction = "both")
  # summary step lm
  summary_step_lm_batch <- summary(step_lm_batch)$coef
  summary_step_lm_batch  <- as.data.frame(summary_step_lm_batch)
  summary_step_lm_batch$terms <- rownames(summary_step_lm_batch)
  # save summary step lm
  write.table(summary_step_lm_batch, file=paste(out_dir,"/",project_name,".eset_bg_log2_rsn.stepAIC_multivariate_model_batch_variables.csv",sep=""),row.names=FALSE,quote=FALSE, sep=",")
  ## anova step #
  anova_step_lm_batch <- anova(step_lm_batch)
  anova_data <- as.data.frame(anova_step_lm_batch)
  anova_data$terms <- rownames(anova_data)
  anova_data <- subset(anova_data, anova_data$terms!="Residuals")
  # best model
  best_model <- paste(anova_data$terms, collapse=" + ")
  best_model <- as.formula( paste(pheno,"~",best_model,sep="") )
  best_model
  # RSQ anova step 
  anova_step_r2 <- round( summary(step_lm_batch)$adj.r.squared, 3)
##
  par(mar=c(10,5,4,2))
  barplot(-log10(anova_data$"Pr(>F)"), las=3, names=c(anova_data$terms) , ylab="ANOVA -log10(P)", main=paste(step_lm_batch$call[2]," R2=",anova_step_r2 ,sep=""),cex.names=0.8,cex.main=0.8,cex.lab=1)
  abline(h=-log10(0.05),col="blue")
  abline(h=-log10(0.05/dim(anova_data)[1]),col="red")
  ## plot ANOVA step P #
  pdf(file=paste(out_dir,"/",project_name,".eset_bg_log2_rsn.",pheno,".stepANOVA_multivariate_model_batch_variables.pdf",sep=""), width=8,height=6 )
  par(mar=c(10,5,4,2))
  barplot(-log10(anova_data$"Pr(>F)"), las=3, names=c(anova_data$terms) , ylab="ANOVA -log10(P)", main=paste(step_lm_batch$call[2]," R2=",anova_step_r2 ,sep=""),cex.names=0.8,cex.main=0.8,cex.lab=1)
  abline(h=-log10(0.05),col="blue")
  abline(h=-log10(0.05/dim(anova_data)[1]),col="red")
  dev.off()
  ## save stepANOVA
  write.table(anova_data , file=paste(out_dir,"/",project_name,".eset_bg_log2_rsn.",pheno,".stepANOVA_multivariate_model_batch_variables.csv",sep=""),row.names=FALSE,quote=FALSE, sep=",")
  cat(" BEST MODEL BASED ON stepAIC [",pheno,"] ~ [",paste(best_model)[3],"] ","\r","\n")
  } else {
    cat(" NICE!: NO SIGNIFICANT ASSOCIATION BETWEEN [ ",pheno," ] ~ [ BATCH PHENOTYPES ]","\r","\n")
    }
  }

##
```

Batch Correction using linear models
-------------------------------------------------------
```{r LM_batch_correction, eval=FALSE}
# get gene expressuion
gx <- exprs(eset_bg_log2_rsn)
n_probes <- dim(gx)[1]
gx <- t(gx)
dim(gx)
gx[1:10,1:10]

# probe nuID names
probe_names <- paste("p_",colnames(gx),sep="") # ADD p as some nuID start with a number
head(probe_names)
colnames(gx) <- probe_names
gx[1:10,1:10]

# make new matrix to write adjusted values to
adj_gx <- gx*0
adj_gx[1:10,1:10]

# best_model
best_model <- paste(anova_data$terms, collapse=" + ")

# get batch phenos
batch_pheno <- tech_pheno[,anova_data$terms]
batch_pheno <- cbind(batch_pheno,gx)
batch_pheno[1:10,1:10]

# loop through each probe and adjust for sig batches
pn <- 1
for(probe in probe_names){
    
    lm_model <- as.formula( paste(probe,"~",best_model,sep="") )
    lm_probe <-  lm( lm_model , data=batch_pheno)
    rsq <- round( summary(lm_probe)$adj.r.squared, 3)
    residual_probe <- lm_probe$residual
    mean_probe_level <- mean(batch_pheno[,probe])
    adjusted_probe_level <- residual_probe + mean_probe_level
    adj_gx[,probe] <- adjusted_probe_level
    
    cat(" doing [",probe ,"] ~ [",best_model,"].RSQ=",rsq,". Progress:",round(pn/n_probes,3),"\r","\n")
    
    pn <- pn + 1
}

# update names and transform back to probe x sample matrix
colnames(adj_gx) <- colnames(gx)
adj_gx <- t(adj_gx)
adj_gx[1:10,1:10]

# make new eset and replace exprs() matrix with new batch adjusted data
#eset_bg_log2_rsn_adj <- eset_bg_log2_rsn
#exprs(eset_bg_log2_rsn_adj) <- adj_gx

# save eset_bg_log2_rsn_adj
#save(eset_bg_log2_rsn_adj, file=paste(out_dir,"/",project_name,".eset_bg_log2_rsn_adj.RData",sep="")  , compress=T)

# QC Plots of eset_bg_log2_rsn_adj
#gx_qc_plots_lumi(eset=eset_bg_log2_rsn_adj, outfile=paste(out_dir,"/",project_name,".eset_bg_log2_rsn_adj",sep="") )

# write_expression_files eset_bg_log2_rsn_adj
#write_expression_files(eset=eset_bg_log2_rsn_adj,outfile= paste(out_dir,"/",project_name,".eset_bg_log2_rsn_adj",sep="") )
       
```

## univariate_models
```{r univariate_model_PCA_Batch_Regressions, eval=FALSE}
## univariate_models
cat(" running full univariate models ","\r","\n")

for(pheno in c("PC1","GROUPS","PHENOTYPE") ) {
  
  univar_results <- data.frame()
  
  for(covar in batch_var_names) {
    pheno_name <- paste(pheno,sep="")
		model <- as.formula( paste(pheno,"~",covar) )
		univar_lm <- lm( model, data=tech_batch)
		summary_univar_lm <- summary(univar_lm)
		rsq <- summary_univar_lm$adj.r.squared
		anova_univar_lm <- anova(univar_lm)
		phenotype <- pheno_name
	  covariate <- paste(covar,sep="")
  	summary_univar_lm_data <- as.data.frame(coef(summary_univar_lm))
		summary_univar_lm_data$adj.r.squared  <- rsq
		summary_univar_lm_data$anova_F  <- anova_univar_lm$F[1]
		summary_univar_lm_data$anova_p <- anova_univar_lm$"Pr(>F)"[1]
		summary_univar_lm_data$terms <- rownames(summary_univar_lm_data)
		summary_univar_lm_data$phenotype <- pheno_name
		summary_univar_lm_data$covariate <- covariate
		univar_results <- rbind(univar_results , summary_univar_lm_data )
    
    if( !is.na(anova_univar_lm$"Pr(>F)"[1]) & anova_univar_lm$"Pr(>F)"[1]<=0.05) {
      cat(" WARNING!: [",pheno,"] ~ [", covar,"] ARE ASSOCIATED, rsq = [",round(rsq,3),"]","\r","\n")
      }
    
    }
# save res
write.table(univar_results, file=paste(out_dir,"/",project_name,".eset_bg_log2_rsn.",pheno,".univariate_model_batch_variables.csv",sep="")  ,sep=",",row.names=FALSE,quote=FALSE);
  }
```


***********************************************************************************************************************************************************

Create Final QC'd Expression data set: Good Probes & Good Samples
------------------------------------------------------------------
```{r create_final_eset, eval=FALSE}

```

***********************************************************************************************************************************************************

Project Summary
------------------------------------------------------------------
```{r project_summary, eval=FALSE}

```

***********************************************************************************************************************************************************


The End!
------------------------------------------------------------------
```{r end, eval=FALSE}
#### RMDFILE=example-r-markdown  
#### Rscript -e "require(knitr); require(markdown); knit('$RMDFILE.rmd', '$RMDFILE.md'); markdownToHTML('$RMDFILE.md', '$RMDFILE.html', options=c('use_xhml'))"
#### pandoc -s example-r-markdown.html -o example-r-markdown.pdf

system( paste(" chmod 776 ",out_dir,"/",project_name,"***",sep="") )
sessionInfo()
```
