```{r setup_R, include=FALSE}
rm(list=ls())
library(knitr)
library(markdown)
library(shiny)
opts_chunk$set(error=FALSE, dev = 'pdf', tidy=TRUE, warning=FALSE, highlight=TRUE)
opts_knit$set(fig.path="figures/plots")
knit_hooks$set(crop = hook_pdfcrop)
options(stringsAsFactors = FALSE)
```

Microarry pre-processing workflow for Illumina BeadArray data
==============================================================
- Stephen Newhouse
- stephen.newhouse@kcl.ac.uk
Example workflow based on real data (GAP). 

# Project Directory and Files
Data files and directories used in this workflow
```{r Files, eval=FALSE}

# Data Directory
"/media/D/expression/GAP_Expression"

# Data Files Exported from GenomeStudio
control_probe_profile_Final_Report.txt
Group_Probe_Profile_Final_Report.txt
probe_annotation_Final_Report.txt
sample_table_Final_Report.txt

# Input for lumiR
Sample_and_Control_Probe_Profile_FinalReport.txt 

# User Provided Data Files
# Use NA to record missing values in batch_info.txt
# Use Unknown to record missing values in pheno_info.txt 

# REQUIRED COLUMNS (MATCH FORMAT SHOWN HERE ie SEX not Sex or Gender etc!):- "Sample.ID","SEX","GROUPS","TISSUE","PHENOTYPE","Study_ID"
pheno_info.txt

# REQUIRED COLUMNS:- "Sample.ID","RIN","RNA_YIELD" and any other related batch info eg dates or processing. 
batch_info.txt


# Naming Convensions
* All UPPERCASE
* SEX = MALE, FEMALE or UNKNOWN
* Missing data = NA for all data. The exceptioins are: SEX,GROUPS,PHENOTYPE, TISSUE. Use UNKNOWN

TO DO: ADD LINK TO Genomestudio SOP and scripts for making lumiR input

```

****

## setwd
This is the full path to the directory where all the raw genomestudio output is stored

```{r setwd, eval=TRUE}
setwd("/media/D/expression/GAP_Expression")
```

## load libs
```{r loadLibs, eval=TRUE, message=FALSE}
# Load libraries 
library(lumi)
library(annotate)
library(lumiHumanAll.db)
library(affy)
library(cluster)
library(impute)
library(WGCNA)
library(gplots)
library(limma)
library(vsn)
library(MBCB)
library(lumiHumanIDMapping)
library(scatterplot3d)
library(relaimpo)
library(plyr)
library(ggplot2)

```

## load source file with some processing functions
email stephen.newhouse@kcl.ac.uk for code. This will all be on git soon
```{r loadSource, eval=TRUE}
# path to gene expression processing scripts
path_to_scripts <- "/media/D/sjnewhouse/GENE_EXPRESSION" 
# load 'em
source(paste(path_to_scripts,"/sjnewhouse_misc_R.R",sep=""))
ls()
```

## set project settings and I/O
User is asked to manually provide these options.  
This sets the working directoty, prjoect name, input and output files, along with qc options for transformation and normalisation methods.  
This project configuration data is written to *.csv file in your project directory.

```{r setProjectOptions, eval=TRUE}
# project directory
project_dir <- "/media/D/expression/GAP_Expression"

# set working dir again
setwd(project_dir)

# project name
project_name <- "GAP"

# output directory for lumi process and plots
processing_date <- format(Sys.Date(),"%d_%m_%Y")
out_dir <- paste(project_dir,"/",project_name,"_lumi_processing_",processing_date ,sep="")

# make project pre-processing directory
make_dir_command <- paste(" if [ ! -e ",out_dir," ]; then mkdir ",out_dir,"; fi",sep="")

system( make_dir_command )

# genomestudio reports
gs_report  <- "/media/D/expression/GAP_Expression/final_reports_genomestudio/Sample_and_Control_Probe_Profile_FinalReport.txt"
gs_probe   <- "/media/D/expression/GAP_Expression/final_reports_genomestudio/Group_Probe_Profile_Final_Report.txt" # genomestudio report
gs_sample  <- "/media/D/expression/GAP_Expression/final_reports_genomestudio/sample_table_Final_Report.txt" # genomestudio report
gs_control <- "/media/D/expression/GAP_Expression/final_reports_genomestudio/control_probe_profile_Final_Report.txt" # genomestudio report
anno_table <- "/media/D/expression/GAP_Expression/final_reports_genomestudio/probe_annotation_Final_Report.txt"

# sample information
# FILE NAME must contain : Sample.ID,SEX,GROUPS,TISSUE,PHENOTYPE,Study_ID
pheno_file <- "/media/D/expression/GAP_Expression/final_reports_genomestudio/pheno_info.txt" 

# batch information
tech_pheno_file <-"/media/D/expression/GAP_Expression/final_reports_genomestudio/batch_info.txt"

# detection call rate threshold
probe_det <- 80
sample_det <- 80

# flag for gender and sampleNetwork 
sex_check <- 1   # DO THIS!! I'm not providing an option to skip this
iac_check <- 1   # DO THIS!! I'm not providing an option to skip this
iac_sd_thrs <- 2 # 2 or 3

# Model based background correction method (MLE as default)
# All data should be background correceted. The recomended methods is MBCB (Model-based Background Correction for Beadarray)
# URL http://www.bioconductor.org/packages/release/bioc/html/MBCB.html
mbcb_method <- "MLE"

# Transformation method
transform_method <- "log2" ## "vst" # log2, vst or both

# Normalisation method
norm_method <- "rsn" ## "rsn" # quantile, rsn, or both

# Folks that done stuff
analyst_email <- "stephen.newhouse@kcl.ac.uk"
analyst_name <-  "Stephen Newhouse"
lab_contact_email <- "charles.curtis@kcl.ac.uk"
lab_contact_name <- "Charle Curtis"

  
# write settings to file
project_settings <- data.frame(
  project_dir=project_dir,
  project_name=project_name,
  out_dir=out_dir,
  gs_report=gs_report,
  gs_probe=gs_probe,
  gs_sample=gs_sample,
  gs_control=gs_control,
  anno_table=anno_table,
  pheno_file=pheno_file,
  tech_pheno_file=tech_pheno_file,
  probe_det=probe_det,
  sample_det=sample_det,
  sex_check=sex_check,
  iac_check=iac_check,
  iac_sd_thrs=iac_sd_thrs,
  mbcb_method=mbcb_method,
  transform_method=transform_method,
  norm_method=norm_method,
  analyst_email=analyst_email,
  analyst_name=analyst_name,
  lab_contact_email=lab_contact_email,
  lab_contact_name=lab_contact_name
  )

# some data wrangling
project_settings <- as.data.frame(t(project_settings))
colnames(project_settings) <- "Project_Setting"
project_settings$Project_Variable <- rownames(project_settings)
project_settings <- project_settings[,c("Project_Variable","Project_Setting")]

# write table to out_dir
write.table(project_settings, file=paste(out_dir,"/",project_name,".project_settings.csv",sep=""),row.names=FALSE,quote=FALSE,sep=",")

# check settings
project_settings

```
****

BEGIN PRE-PROCESSING
=====================

Raw Expression Set
-------------------

## 1. read raw gene expression data 
```{r lumiR, tidy=TRUE, eval=TRUE}

# raw input 
# This is the 1) Probe Profile, 2) Control Probe Profile and 3) Sample Table, Final Reports exported from GenomeStudio, all concatenated 
if(is.na(gs_report))  stop(" WARNING!: YOU HAVENT PROVIDED ANY DATA TO READ" )

# read raw gene expression data from genomestudio reports and create ExpressionSet

eset_raw <- lumiR( paste(gs_report), 
                  lib.mapping="lumiHumanIDMapping",
                  checkDupId=TRUE,
                  detectionTh = 0.01,
                  convertNuID=TRUE,
                  inputAnnotation=TRUE,
                  annotationColumn=c('PROBE_ID','CHROMOSOME','SYMBOL','DEFINITION','ACCESSION','ENTREZ_GENE_ID',
                                       'PROBE_TYPE','PROBE_START','PROBE_SEQUENCE','PROBE_CHR_ORIENTATION',
                                       'PROBE_COORDINATES','CHROMOSOME','TRANSCRIPT','ILMN_GENE','REFSEQ_ID','UNIGENE_ID','SYMBOL','PROTEIN_PRODUCT'),
                   QC=TRUE)

# check it
eset_raw

# n_expression_chips
n_expression_chips <- dim(eset_raw)[2]
cat("  WARNING!: The number of expression chips=[",dim(eset_raw)[2],"]","\r","\n")
```

## 2. read in sample and batch information
```{r readSamplePhenoAndBatchInfo, eval=TRUE}

# gs_sample
if(is.na(gs_sample))  stop(" WARNING!: YOU HAVENT PROVIDED ANY SAMPLE INFORMATION!!!" )
gs_sample

gs_sample_data <- read.table(paste(gs_sample) ,skip=8,as.is=T,fill=T,head=T,sep="\t")
rownames(gs_sample_data) <- gs_sample_data$Sample.ID
gs_sample_data <- gs_sample_data[,names(gs_sample_data)!="X"] # added this as genomestudio likes to add mystery columns to the end of this report 
n_samples <- dim(gs_sample_data)[1]  # number of rows ie samples

save(gs_sample_data,file=paste(out_dir,"/",project_name,".gs_sample_data.RData",sep="") )

#  pheno_file
if(is.na(pheno_file))  stop(" WARNING!: YOU HAVENT PROVIDED ANY PHENOTYPE INFORMATION!!!" )
pheno_file

pheno_dat <- read.table(paste(pheno_file), as.is=T,fill=T,head=T,sep="\t")
save(pheno_dat,file=paste(out_dir,"/",project_name,".pheno_dat.RData",sep="") )
has_pheno_cols <- c("Sample.ID","SEX","GROUPS","TISSUE","PHENOTYPE","Study_ID") %in% names(pheno_dat);
missing_pheno_cols <- "FALSE" %in% has_pheno_cols
if(missing_pheno_cols == "TRUE") stop(" WARNING!: YOU ARE MISSING ESSENTIAL SAMPLE INFORMATION! MAKE SURE YOUR PHENO_FILE HAS:- Sample.ID,SEX,GROUPS,TISSUE,PHENOTYPE,Study_ID !!!")
raw_n_pheno_dat <- dim(pheno_dat)[1] # number of rows ie samples

cat(" Running toupper() on PHENOTYPE, GROUP AND TISSUE variables to fix potential case issues","\r")
# fix case
pheno_dat$PHENOTYPE <- toupper(pheno_dat$PHENOTYPE)
pheno_dat$SEX <- toupper(pheno_dat$SEX)
pheno_dat$GROUPS <- toupper(pheno_dat$GROUPS)
pheno_dat$TISSUE <- toupper(pheno_dat$TISSUE)
# a quick looksee at counts
table(pheno_dat$PHENOTYPE)
table(pheno_dat$GROUPS)
table(pheno_dat$TISSUE)
table(pheno_dat$SEX)

# tech_pheno_file
if(is.na(tech_pheno_file))  stop(" WARNING!: YOU HAVENT PROVIDED ANY BATCH INFORMATION!!!" )
tech_pheno_file

tech_pheno <- read.table(paste(tech_pheno_file),head=T,sep="\t")
tech_pheno$Sentrix.Barcode <- as.character(tech_pheno$Sentrix.Barcode)
rownames(tech_pheno) <- tech_pheno$Sample.ID
colnames(tech_pheno) <- paste("tech.",names(tech_pheno),sep="")
colnames(tech_pheno) <- c("Sample.ID", names(tech_pheno[,-1]))
save(tech_pheno,file=paste(out_dir,"/",project_name,".tech_pheno.RData",sep="") )

# get pData()
eset_samples <- pData(eset_raw)
# add chip order and flad for "has expression data" to eset_samples (pData)
eset_samples$has_expression <- 1
eset_samples$chip_order <- 1:dim(eset_samples)[1]
save(eset_samples,file=paste(out_dir,"/",project_name,".eset_samples.RData",sep="") )

# col names
names(eset_samples) 
names(gs_sample_data)
names(pheno_dat)
names(tech_pheno)

# head
head(eset_samples) 
head(gs_sample_data)
head(pheno_dat)
head(tech_pheno)

# quick check
# these should all have the same number of rows or samples!
dim(eset_samples);dim(gs_sample_data);dim(pheno_dat);dim(tech_pheno)

# Venn of Sample.ID
ex <- eset_samples$sampleID
pp <- pheno_dat$Sample.ID
tt <- tech_pheno$Sample.ID
venninput  <-list(ArrayExpression=ex,Batch_Info=tt,Pheno_Info=pp)
venn(venninput)
#dev.off()
```

## 2.1 check for duplicate Study_ID
```{r check_for_ duplicate Study_ID, eval=TRUE}
# check for duplicate Study_ID
tab_id <- table(pheno_dat$Study_ID)
tab_id_df <- as.data.frame(tab_id)
colnames(tab_id_df) <- c("Study_ID","Freq")
dupe_samples <- subset(tab_id_df,tab_id_df$Freq>=2) 
cat("  WARNING!: You have duplicate Study_IDs. N=[",dim(dupe_samples)[1],"]","\r","\n")
dupe_samples
write.table(dupe_samples,file=paste(out_dir,"/",project_name,".dupe_Study_IDs.txt",sep=""),sep="\t",quote=FALSE,row.names=FALSE)
# n_unique_study_id
n_unique_study_id <- length(unique(tab_id_df$Study_ID))
cat("  WARNING!: The number of unique Study_Ids=[",n_unique_study_id,"]","\r","\n")

```

## 3. check eset_samples, sample & batch info Sample.ID's match in names and numbers & merge all
```{r MatchSamplePhenoAndBatchInfo, eval=TRUE}
cat(" Megreing pdata, pheno data, batch information adn genomestudio samople data","\r","\n")
# 1. merge eset_samples with pheno_dat. 
# Keep ALL overlaps only
eset_pheno_merge <- merge(eset_samples,pheno_dat,by.x="sampleID",by.y="Sample.ID" )
eset_pheno_merge <- eset_pheno_merge[order(eset_pheno_merge$chip_order),]
dim(eset_samples);dim(eset_pheno_merge) # check size

# 2. merge eset_pheno_merge with tech_pheno
eset_pheno_batch_merge <- merge(eset_pheno_merge,tech_pheno,by.x="sampleID",by.y="Sample.ID" )
eset_pheno_batch_merge <- eset_pheno_batch_merge[order(eset_pheno_batch_merge$chip_order),]
dim(eset_samples);dim(eset_pheno_merge);dim(eset_pheno_batch_merge) # check size

# 3. merge all with genomestudio final report
eset_pheno_batch_gs_merge <- merge(eset_pheno_batch_merge,gs_sample_data,by.x="sampleID",by.y="Sample.ID" )
eset_pheno_batch_gs_merge <- eset_pheno_batch_gs_merge[order(eset_pheno_batch_gs_merge$chip_order),]

# final look at numbers in each merged data set
dim(eset_samples);dim(eset_pheno_merge);dim(eset_pheno_batch_merge);dim(eset_pheno_batch_gs_merge)

# names
names(eset_pheno_batch_gs_merge)

```

## 4. Subset raw ExpressionSet to matched/complete Sample.IDs & Update pData() slot.
```{r subsetEsetRaw, eval=TRUE}

# samples in gene expression data
samples_eset <- pData(eset_raw)$sampleID
length(samples_eset)

# samples with complete data
samples_complete_data <- eset_pheno_batch_gs_merge$sampleID
length(samples_complete_data)  

# samples to remove
samples_to_remove <- (samples_eset %in% samples_complete_data)==FALSE  
samples_to_remove <- pData(eset_raw)$sampleID[samples_to_remove]
length(samples_to_remove)  
  
# rename eset_raw & save
eset_raw_preqc <- eset_raw
save(eset_raw_preqc, file=paste(out_dir,"/",project_name,".eset_raw_preqc.RData",sep=""))

# subset eset_raw
eset_raw <- removeSamples_eset_lumi(eset=eset_raw_preqc,sampleRemove=samples_to_remove)
eset_raw

# update pData
old_pdata <- pData(eset_raw)
old_pdata$old_order <- 1:dim(old_pdata)[1]

# merge with eset_pheno_batch_gs_merge
new_pdata <- merge(old_pdata, eset_pheno_batch_gs_merge, by.x="sampleID", by.y="sampleID", all=TRUE,sort=FALSE)
new_pdata <- new_pdata[order(new_pdata$old_order),]

# remove columns old_order has_expression chip_order
new_pdata <- new_pdata[,-c(2,3,4)]

# update rownames
rownames(new_pdata) <- new_pdata$sampleID

# update pData slot
pData(eset_raw) <- new_pdata
dim(pData(eset_raw))

# check it
eset_raw 

## n_expression_chips_with_data
n_expression_chips_with_data <- dim(eset_raw)[2]
    
```

## 5. Add nuID to fData
```{r updateFeatureData, eval=TRUE}
 #Add nuID to fData
fData(eset_raw)$nuID <- rownames(fData(eset_raw))
head(fData(eset_raw))
```

## 6. Save updated raw ExpressionSet eset_raw
```{r saveEsetRaw, eval=TRUE}
# Save updated raw ExpressionSet eset_raw
save(eset_raw, file=paste(out_dir,"/",project_name,".eset_raw.RData",sep=""))
```

## 7. Write data files to out_dir for eset_raw
```{r writeEsetRawData, eval=TRUE}
# Write data files to out_dir for eset_raw
write_expression_files(eset=eset_raw,outfile=paste(out_dir,"/",project_name,".eset_raw",sep="") )
```

## 8. Basic QC plots on eset_raw
```{r basicQCplots_eset_raw, eval=TRUE}
gx_qc_plots_lumi_2(eset_raw)
```

## 9. SampleNetwork on eset_raw for all samples as a first pass
```{r SampleNetwork_raw_data_all, eval=TRUE}
datExprs <- exprs(eset_raw)
samle_names <- sampleNames(eset_raw)
IAC=cor(datExprs, method="p",use="p")
diag(IAC)=0
A.IAC=((1+IAC)/2)^2  ## ADJACENCY MATRIX
# fundamentalNetworkConcepts
FNC=fundamentalNetworkConcepts(A.IAC) ## WGCNA
K2=FNC$ScaledConnectivity
Z.K=round( (K2-mean(K2))/sd(K2) ,3)
Z.C=round( (FNC$ClusterCoef-mean(FNC$ClusterCoef))/sd(FNC$ClusterCoef),3)
# cor K,C
rho <- signif(cor.test(Z.K,Z.C,method="s")$estimate,2)
rho_pvalue <- signif(cor.test(Z.K,Z.C,method="s")$p.value,2)
# Z.K_outliers 
Z.K_outliers <- Z.K < -iac_sd_thrs
Z.K_outliers <- names(Z.K_outliers[Z.K_outliers==TRUE])
n_outliers <- length(Z.K_outliers)
mean_IAC <- signif(mean(IAC[upper.tri(IAC)]),2)
min_Z.K <- min(Z.K)
cat(" Number of Z.K outliers=[", n_outliers,"]","\r","\n")
cat(" mean_IAC=[", mean_IAC,"]","\r","\n")
cat(" cor(Z.k,Z.C)=[", rho,"] P=[",rho_pvalue,"]","\r","\n")
# print chip ids
Z.K_outliers
# get these bad samples from pData and update pdata to include these metrics
pData(eset_raw)$Z.K_eset_raw <- Z.K
pData(eset_raw)$Z.C_eset_raw <- Z.C
pData(eset_raw)$cor_Z.K.Z.C_eset_raw <- rho
pData(eset_raw)$cor_p_Z.K.Z.C_eset_ra <- rho_pvalue
# take a look at these outliers
samples_out <- pData(eset_raw[,Z.K_outliers])
head(samples_out)
table(samples_out$GROUPS)
table(samples_out$PHENOTYPE)
table(samples_out$SEX)
table(samples_out$tech.Sentrix.Barcode)
#
# Save updated raw ExpressionSet eset_raw
eset_raw_Z.K_outliers <- Z.K_outliers
save(eset_raw_Z.K_outliers  , file=paste(out_dir,"/",project_name,".eset_raw_Z.K_outliers.RData",sep=""))
save(eset_raw, file=paste(out_dir,"/",project_name,".eset_raw.RData",sep=""))
# Write data files to out_dir for eset_raw
write_expression_files(eset=eset_raw,outfile=paste(out_dir,"/",project_name,".eset_raw",sep="") )
```
